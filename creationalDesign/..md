Creational Design Patterns are used to **create objects in a controlled, flexible, and reusable way**.
They help you avoid tightly coupling your code to object creation logic.

There are **5 main Creational Design Patterns**:

---

# âœ… **1. Singleton Pattern**

Ensures **only one instance** of a class exists and provides a global access point.

### When to use:

* Logging
* Database connection
* Configuration manager

### Example (JavaScript)

```js
class Database {
  constructor() {
    if (Database.instance) return Database.instance;
    this.connection = "Connected to DB";
    Database.instance = this;
  }
}

const db1 = new Database();
const db2 = new Database();

console.log(db1 === db2); // true
```

---

# âœ… **2. Factory Method Pattern**

A method is responsible for creating objects â€” **decides which class to instantiate at runtime**.

### When to use:

* When the exact type of object depends on input
* Replace `new` with flexible object creation

### Example

```js
class Developer {
  constructor() { this.role = "Developer"; }
}
class Tester {
  constructor() { this.role = "Tester"; }
}

class EmployeeFactory {
  static create(type) {
    if (type === "developer") return new Developer();
    if (type === "tester") return new Tester();
  }
}

const emp = EmployeeFactory.create("developer");
console.log(emp.role); // Developer
```

---

# âœ… **3. Abstract Factory Pattern**

A factory that creates **families of related objects**, without specifying concrete classes.

### When to use:

* UI themes (dark/light)
* OS-specific UI components (Windows/Mac/Linux)

### Example

```js
class WinButton { paint() { console.log("Windows Button"); } }
class MacButton { paint() { console.log("Mac Button"); } }

class WinFactory {
  createButton() { return new WinButton(); }
}
class MacFactory {
  createButton() { return new MacButton(); }
}

function app(factory) {
  const btn = factory.createButton();
  btn.paint();
}

app(new WinFactory()); // Windows Button
```

---

# âœ… **4. Builder Pattern**

Step-by-step construction of a complex object.
Useful when constructors have **too many parameters**.

### When to use:

* Build objects with many optional fields
* Building SQL queries
* Constructing cars or houses

### Example

```js
class User {
  constructor(builder) {
    this.name = builder.name;
    this.age = builder.age;
    this.phone = builder.phone;
  }
}

class UserBuilder {
  setName(name) { this.name = name; return this; }
  setAge(age) { this.age = age; return this; }
  setPhone(phone) { this.phone = phone; return this; }
  build() { return new User(this); }
}

const user = new UserBuilder()
  .setName("Rahul")
  .setAge(26)
  .setPhone("9999")
  .build();

console.log(user);
```

---

# âœ… **5. Prototype Pattern**

Create **clones (copies)** of existing objects instead of creating new ones.

### When to use:

* When object creation is costly
* When you want to duplicate an object with minor changes

### Example

```js
const car = {
  model: "BMW",
  clone() {
    return { ...this };
  }
};

const car2 = car.clone();
car2.model = "Audi";

console.log(car.model);  // BMW
console.log(car2.model); // Audi
```

---

# ðŸŽ¯ **Quick Summary Table**

| Pattern              | Purpose                       | Example Use Case      |
| -------------------- | ----------------------------- | --------------------- |
| **Singleton**        | One instance globally         | DB connection         |
| **Factory Method**   | Choose object type at runtime | Hiring system         |
| **Abstract Factory** | Create related objects        | UI theme system       |
| **Builder**          | Build complex objects         | User profile builder  |
| **Prototype**        | Clone objects                 | Game character copies |

---

If you want, I can also explain:

ðŸ”¥ Structural Design Patterns
ðŸ”¥ Behavioral Design Patterns
ðŸ”¥ UML diagrams for patterns
ðŸ”¥ Real-world interview examples

Just tell me!
